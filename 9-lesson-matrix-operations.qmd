# Matrix Operations {#sec-matrixops}

```{r setup, include=FALSE}
    require(ggraph)
    require(tidygraph)
    require(igraph)
    require(kableExtra)
    require(expm)
```

As we saw in the #sec-grtomat, a matrix is a two-dimensional array of numbers. A matrix is two-dimensional because it arranges numbers according to the intersection of a **row dimension** and a **column dimension**. Matrices, therefore are perfect for storing network information, because we can put the nodes in the row and column dimension and then record characteristics of each **dyad** in the network (like whether they are adjacent in the corresponding graph) in matrix form. We can of course record all kinds of other relationships between dyads, like the length of the shortest paths linking them, the number of shortest paths, the number of common neighbors and so forth. 


```{r}
#| label: fig-rel
#| fig-cap: "Undirected graphs representing different social relationships"
#| fig-cap-location: margin
#| fig-subcap:
#|   - "A graph representing hanging out relations (blue)."
#|   - "A graph representing co-working relations (red)." 
#|   - "A graph representing both hanging out and co-working relations (purple)."
#| layout-ncol: 3
#| fig-width: 8
#| fig-height: 8

set.seed(859)

   gr1 <- play_islands(3, 4, m = 1, p_within = 0.8) %>% 
     activate(nodes) %>% 
     mutate(name = toupper(letters[1:12])) %>% 
     simplify()
     l <- ggraph(gr1, layout = 'tree')
     l <- as.matrix(l$data[, 1:2])
     p <- ggraph(gr1, layout = l)
     p <- p + geom_edge_link(color = "steelblue", width = 1.15) 
     p <- p + geom_node_point(aes(x = x, y = y), size = 24, color = "tan2") 
     p <- p + geom_node_text(aes(label = name), size = 12, color = "white")
     p <- p + theme_graph() 
     p
     
   gr2 <- play_islands(4, 3, m = 1, p_within = 1) %>% 
     activate(nodes) %>% 
     mutate(name = toupper(letters[1:12])) %>% 
     simplify()
     p <- ggraph(gr2, layout = l)
     p <- p + geom_edge_link(color = "firebrick", width = 1.15) 
     p <- p + geom_node_point(aes(x = x, y = y), size = 24, color = "tan2") 
     p <- p + geom_node_text(aes(label = name), size = 12, color = "white")
     p <- p + theme_graph() 
     p
     
     A1 <- as.matrix(as_adjacency_matrix(gr1))
     A2 <- as.matrix(as_adjacency_matrix(gr2))
     A <- A1 * A2
     gr <- graph_from_adjacency_matrix(A)
     p <- ggraph(gr, layout = l)
     p <- p + geom_edge_link(color = "purple", width = 3) 
     p <- p + geom_node_point(aes(x = x, y = y), size = 24, color = "tan2") 
     p <- p + geom_node_text(aes(label = name), size = 12, color = "white")
     p <- p + theme_graph() 
     p
```

```{r}
#| label: tbl-rel
#| tbl-cap: "Adjancency matrices corresponding to networks defined by different relationships." 
#| tbl-subcap:
#|   - "Hanging out relationships."
#|   - "Co-working relationships."
#| layout-ncol: 1


     A1 <- as.matrix(as_adjacency_matrix(gr1))
     diag(A1) <- "--"
     kbl(A1, format = "html", align = "c")  %>% 
     column_spec(1, bold = TRUE) %>% 
     kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
    
     A2 <- as.matrix(as_adjacency_matrix(gr2))
     diag(A2) <- "--"
     kbl(A2, format = "html", align = "c")  %>% 
     column_spec(1, bold = TRUE) %>% 
     kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

Of course, since matrices are just array of *numbers* one powerful thing that we can do is arithmetic and algebraic operations on them. These including summing, multiplying, taking powers of matrices and so forth. In this lesson, we discuss some basic matrix operations and their relevance for the analysis of social networks. 

Our running example will be the pair of graphs shown in @fig-rel. Supppose this is a network of twelve people who work at a (very) small company. We have recorded two types of relationships for each pair of persons: Whether *they hang out together* after work, and whether they get assigned to *work together in team projects* (we will call these "hang out" and "co-working" relations for short).

@fig-rel-1, composed of nodes joined by blue edges, represents hanging out relations; @fig-rel-2 represents co-working relations. The corresponding **adjacency matrices** for the @fig-rel networks are shown in @tbl-rel. @tbl-rel-1 (let's call it $\mathbf{H}$) records hanging out relations and @tbl-rel-2 (let's call it $\mathbf{C}$) records co-working relations.  

## Matrix Addition
Perhaps the simplest operation we can do with matrices is add them up. To add two matrices, we simply add up the corresponding entries in each cell. In matrix notation:

$$
\mathbf{H} + \mathbf{C} = h_{ij} + c_{ij}
$$ {#eq-matadd}

Where $h_{ij}$ is the corresponding entry for nodes *i* and *j* in the hanging out adjacency matrix $\mathbf{H}$, and $c_{ij}$ is the same entry in the co-working adjacency matrix $\mathbf{C}$. 

Why would we want to do this? Well, if we were studying the network shown in @fig-rel, we might be interested in which dyads have **uniplex** (or single-stranded) relations, and which ones have **multiplex** (or multi-stranded) relations. That is, while some actors in the network *either* hang out together or work together, some of the do *both*. Adding up the adjacency matrices shown in @tbl-rel, will tell us who these are. The result is shown in @tbl-mult.

```{r}
#| label: tbl-mult 
#| tbl-cap: "Uniplex and Multiplex relationship matrix."
#| tbl-cap-location: margin

     A1 <- as.matrix(as_adjacency_matrix(gr1))
     A2 <- as.matrix(as_adjacency_matrix(gr2))
     A <- A1 + A2

     diag(A) <- "--"
     kbl(A, format = "html", align = "c")  %>% 
     column_spec(1, bold = TRUE) %>% 
     kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

@tbl-mult shows that the $BC$ dyad has a multiplex relation (there is a "2" in the corresponding cell entry) and so does the $AC$, $FH$, $GH$, $EF$, and $JL$ dyads. 


## The Matrix Dot Product
Another way of figuring out which pairs of people in a network have multiplex ties is to compute the **matrix dot product** (symbol: $\cdot$). Just like matrix addition, we find the matrix dot product by *multiplying* the corresponding entries in each of the matrices. In matrix format:

$$
\mathbf{H} \mathbf{\cdot} \mathbf{C} = h_{ij} \times c_{ij}
$$ {#eq-matadd}

If we take the dot product of two adjancency matrices like $\mathbf{H}$ and $\mathbf{C}$, then the resulting matrix will have a one in a given cell *only if* $h_{ij} = 1$ and $c_{ij} = 1$. Otherwise, it will have a zero. This means that the dot product of two adjacency matrices will retain *only* the multiplex ties and erase all the other ones. The result of the dot products of the adjancency matrices shown in @tbl-rel is shown in @tbl-dot.  

```{r}
#| label: tbl-dot
#| tbl-cap: "Multiplex relationship matrix."
#| tbl-cap-location: margin

     A1 <- as.matrix(as_adjacency_matrix(gr1))
     A2 <- as.matrix(as_adjacency_matrix(gr2))
     A <- A1 * A2

     diag(A) <- "--"
     kbl(A, format = "html", align = "c")  %>% 
     column_spec(1, bold = TRUE) %>% 
     kable_styling(bootstrap_options = c("striped", "hover", "condensed", "responsive"))
```

As we can see, the only dyads that have non-zero entries in @tbl-dot are the multiplex dyads in @tbl-mult. The resulting network, composed of the combined "hanging + co-working" relation is shown in @fig-rel-3. Note that this network is much more sparse than either of the other two, since there's an edge between nodes only when they are adjacent in *both* the @fig-rel-1 and @fig-rel-2 networks. 

## The Matrix Transpose {#sec-trans}
One thing we can do with a matrix is "turn it 90 degrees" so that the rows of the new matrix are equal to the columns of the resulting matrix and the columns of the first matrix equal the rows of the resulting matrix. This is called the **matrix transpose** (symbol: $^T$). 

For instance, if we have a matrix $\mathbf{A}_{4 \times 5}$ of dimensions $4 \times 5$ (four rows and five columns), then the transpose $A^T_{5 \times 4}$ will have five rows and four columns, with the respective entries in each matrix given by the formula:

$$
a_{ij} = a^T_{ji}
$$
That is the number that in the first matrix appears in the $i^{th}$ row and $j^{th}$ column now appears in the transposed version of the matrix in the $j^{th}$ row and $i^{th}$ column. 

An example of a matrix and its tranpose is shown in @tbl-trans.

```{r}
#| label: tbl-trans 
#| tbl-cap: A matrix and its transpose
#| tbl-subcap: 
#|   - "Original Matrix."
#|   - "Transposed Matrix."
#| layout-ncol: 2

A <- matrix(c(3, 7, 4, 5, 2, 4, 9, 6, 3, 5, 5, 3, 2, 4, 4), nrow = 5)
B <- t(A)

kbl(A, align = "c", format = "html") %>%
    kable_styling(full_width = TRUE,
                  bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
    column_spec(1:3, extra_css = "border-right: 0.75px solid;") %>% 
    row_spec(1:5, extra_css = "border-bottom: 0.75px solid;") %>%
    column_spec(1, extra_css = "border-left: 0.75px solid;") %>% 
    row_spec(1, extra_css = "border-top: 0.75px solid;") 



kbl(B, align = "c", format = "html") %>%
    kable_styling(full_width = TRUE,
                  bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
    column_spec(1:5, extra_css = "border-right: 0.75px solid;") %>% 
    row_spec(1:3, extra_css = "border-bottom: 0.75px solid;") %>%
    column_spec(1, extra_css = "border-left: 0.75px solid;") %>% 
    row_spec(1, extra_css = "border-top: 0.75px solid;")
```

So let's check out how the transpose works. The original matrix in @tbl-trans-1 has five rows and three columns. The transposed matrix has three rows and five columns. We can find the same numbers in the original and transposed matrices by switching the rows and columns. Thus, in the original matrix, the number in third row and second column is a six ($a_{32} = 6$). In the transposed version of the matrix, that same six is in second row and third column ($a^T_{23} = 6$). If you check, you'll see that's the case for each number! Thus, the transposed version of a matrix has the same information as the original, it is just that the rows and columns are switched. While this might seem like a totally useless thing to do (or learn) at the moment, we will see that the matrix transpose comes in very handy in the analysis of social networks, and particular in the analysis of **two mode networks** and **cliques**. 

## Matrix Multiplication
Matrix multiplication (symbol: $\times$) is perhaps the more complex of the matrix algebra operations we will cover. It is a bit involved, but relatively easy once you get the hang of it. We will begin with a simple example before doing more complicated stuff. 

### Matrix Multiplication Rules

First, we will let out the basic rules of matrix multiplication:

- You can always multiply two matrices *as long as the number of columns of the first matrix equal the rows of the second matrix*. 
- When the number of columns of a matrix equal the number of rows of another matrix we say that the the two matrices are **conformable**. When this is not the case, we say the matrices are **non-conformable**.

- Thus, another way of stating the first rule is that *only the product of conformable matrices is defined*. If the matrices are not conformable then their product is not defined (e.g., there is no answer to the question of what we get if we multiply them!)

- This means that unlike numbers or the matrix dot product, where the order of the two things you are multiplying doesn't matter ($4 \times 3 = 3 \times 4$ or $\mathbf{A} \cdot \mathbf{B} = \mathbf{B} \cdot \mathbf{A}$), in matrix multiplication it *does* matter. Alas, for any two matrices $\mathbf{A}$ and $\mathbf{B}$,

$$
\mathbf{A} \times \mathbf{B} \neq \mathbf{B} \times \mathbf{A}
$$

- Because, by definition, as discussed in @sec-trans the rows of a matrix are equal to the columns of its transpose, and vice versa. The product of a matrix times its transpose and the transpose times the original matrix is always defined, no matter what the dimensions of the original matrix are. Thus,

$$
\mathbf{A} \times \mathbf{A}^T = defined! 
$$
$$
\mathbf{A}^T \times \mathbf{A} = defined!
$$

- When you multiply a matrix times its transpose, the *dimensions of the resulting matrix will be equal to the number of rows of the first matrix and the number of columns of the second matrix*. For instance, say matrix  $\mathbf{A}_{5 \times 3}$ is of dimensions $5 \times 3$ (like the matrix shown in @tbl-trans1). Then its transpose $A^T_{3 \times 5}$ will be of dimensions $3 \times 5$ (like the matrix shown in @tbl-trans-2). That means the product of the matrix times its transpose will be:

$$
\mathbf{A}_{5 \times 3} \times \mathbf{A}_{3 \times 5}^T = B_{5 \times 5}
$$ {#eq-matmult1}

- @eq-matmult1 says that a five by three matrix multiplied by its transposed yields a product matrix $\mathbf{B}$ of dimensions five by five (a square matrix with five rows and five columns). In the same way,

$$
\mathbf{A}_{3 \times 5}^T \times \mathbf{A}_{5 \times 3} = B_{3 \times 3}
$$ {#eq-matmult2}

- @eq-matmult2 says that the transpose of a five by three matrix multiplied by the original yields a product matrix $\mathbf{B}$ of dimensions thre by three (a square matrix with three rows and three columns).

- You can multiply a matrix times itself to get **matrix powers** but only if matrix is a **square matrix** (has the same number of rows and columns). Thus,

$$
A^2 = A \times A 
$$
$$
A^3 = A \times A \times A 
$$
$$
A^4 = A \times A \times A \times A 
$$
$$
A^n = A \times A \times A \times A \ldots 
$$

- For all square matrices $\mathbf{A}$ of any dimension. Since matrices used to represent social networks, like the **adjacency matrix** are square matrices, that means that you can always find the **matrix powers** of an adjacency matrix. 

### Matrix Multiplication Examples
Now let's see some examples of how matrix multiplication works. @tbl-prod shows the result of multiplying the matrix shown in @tbl-trans-1 times its transpose, shown in @tbl-trans-2.

```{r}
#| label: tbl-prod 
#| tbl-cap: Matrix resulting from multiplying a matrix times its transpose
#| tbl-cap-location: margin

    B <- A %*% t(A)
    kbl(B, align = "c", format = "html") %>%
    kable_styling(full_width = TRUE,
                  bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
    column_spec(1:5, extra_css = "border-right: 0.75px solid;") %>% 
    row_spec(1:5, extra_css = "border-bottom: 0.75px solid;") %>%
    column_spec(1, extra_css = "border-left: 0.75px solid;") %>% 
    row_spec(1, extra_css = "border-top: 0.75px solid;") 
```

Now where the heck did these numbers come from? Don't panic. We'll break it down. First, let's begin with the number $50$ in cell corresponding to the *first row* and *first column* of @tbl-prod. To find out where this number came from, let's look at the *first row* of @tbl-trans-1, composed of the vector $\{3, 4, 5\}$, and the *first-column* of @tbl-trans-2, composed of the same vector $\{3, 4, 5\}$. Now, the number $50$ comes from the fact that we multiply each of the corresponding entries of the two vectors, and then add them up, as follows:

$$
(3 \times 3) + (4 \times 4) + (5 \times 5) = `r 3*3` + `r 4*4` + `r 5*5` = `r 3*3 + 4*4 + 5*5`
$$

Neat! Now let's see where the number $74$ in the *fourth row* and *second column* of @tbl-prod came from. For that we look at the entries in the *fourth row* of @tbl-trans-1, composed of the vector $\{5, 3, 4\}$ and the *second column* of @tbl-trans-2 composed of the vector $\{7, 9, 3\}$. Like before, we take the first number of the first vector and multiply it by the first number of the second vector, the second number of the first vector and multiply it by the second number of the second vector, and the third number of the first vector and multiply it by the third number of the second vector and add up the results:


$$
(5 \times 7) + (3 \times 9) + (4 \times 3) = `r 5*7` + `r 3*9` + `r 4*3` = `r 5*7 + 3*9 + 4*3`
$$
And we keep on going like this to get each of the twenty five numbers in @tbl-prod (there are twenty five numbers because @tbl-prod has five rows and five columns and five times five equal twenty five). In general terms, the number in the $i^{th}$ row and $j^{th}$ column of @tbl-prod is equal to the sum of the products of the numbers in the $i^{th}$ row of the @tbl-trans-1 and the $j^{th}$ column of @tbl-trans-2. 

Note that the resulting product matrix shown in @tbl-prod is **symmetric**. The same numbers that appear in the upper-triangle also appear in the lower triangle, such that $b_{ij} = b_{ji}$. So once you know the numbers in one of the triangles, you can fill up the numbers in the other one without having to do all the multiplying and adding up!

Now, let's multiply the matrix in @tbl-trans-2 times the matrix in @tbl-trans-1. As the rules of matrix multiplication show, this will result in a matrix of dimensions $3 \times 3$ because @tbl-trans-2 has three rows and $tbl-trans-1 has three columns. This is shown in @tbl-prod2.


```{r}
#| label: tbl-prod2
#| tbl-cap: Matrix resulting from multiplying a matrix times its transpose
#| tbl-cap-location: margin

    B <- t(A) %*% A
    kbl(B, align = "c", format = "html") %>%
    kable_styling(full_width = TRUE,
                  bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
    column_spec(1:3, extra_css = "border-right: 0.75px solid;") %>% 
    row_spec(1:3, extra_css = "border-bottom: 0.75px solid;") %>%
    column_spec(1, extra_css = "border-left: 0.75px solid;") %>% 
    row_spec(1, extra_css = "border-top: 0.75px solid;") 
```

Like before, if we want to figure out where the number $72$ in the third row and first column of @tbl-prod2 came from, we go to the first row of @tbl-trans-2 composed of the vector $\{5, 3, 2, 4, 4\}$ and the first column of @tbl-trans-1, composed of the vector $\{3, 7, 4, 5, 2\}$ match up each number in terms of order, multiplying them and add up the result:

$$
(5 \times 3) + (3 \times 7) + (2 \times 4) + (4 \times 5) + (4 \times 2) = 
$$

$$
`r 5*3` + `r 3*7` + `r 2*4` + `r 4*5` + `r 4*2` = `r 5*3 + 3*7 + 2*4 + 4*5 + 4*2`
$$

```{r}
#| label: tbl-pow
#| tbl-cap: Powers of a matrix. 
#| tbl-subcap: 
#|   - "A matrix."
#|   - "Matrix squared."
#|   - "Matrix cubed."
#| tbl-cap-location: margin 
#| layout-ncol: 3

    A <- matrix(c(0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0), nrow = 4, byrow = TRUE)
    A2 <- A %*% A
    A3 <- A2 %*% A
    
    kbl(A, align = "c", format = "html") %>%
    kable_styling(full_width = TRUE,
                  bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
    column_spec(1:4, extra_css = "border-right: 0.75px solid;") %>% 
    row_spec(1:4, extra_css = "border-bottom: 0.75px solid;") %>%
    column_spec(1, extra_css = "border-left: 0.75px solid;") %>% 
    row_spec(1, extra_css = "border-top: 0.75px solid;") 
    
    kbl(A2, align = "c", format = "html") %>%
    kable_styling(full_width = TRUE,
                  bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
    column_spec(1:4, extra_css = "border-right: 0.75px solid;") %>% 
    row_spec(1:4, extra_css = "border-bottom: 0.75px solid;") %>%
    column_spec(1, extra_css = "border-left: 0.75px solid;") %>% 
    row_spec(1, extra_css = "border-top: 0.75px solid;") 
        
    kbl(A3, align = "c", format = "html") %>%
    kable_styling(full_width = TRUE,
                  bootstrap_options = c("striped", "hover", "condensed", "responsive")) %>% 
    column_spec(1:4, extra_css = "border-right: 0.75px solid;") %>% 
    row_spec(1:4, extra_css = "border-bottom: 0.75px solid;") %>%
    column_spec(1, extra_css = "border-left: 0.75px solid;") %>% 
    row_spec(1, extra_css = "border-top: 0.75px solid;") 
```

Matrix powers work the same as regular matrix multiplication, except that we are working on just one matrix not two. So for instance, the number $2$ in the first row and third column of @tbl-pow-2 comes from the numbers in the first row of @tbl-pow-1 ($\{0, 1, 0, 1\}$) and the numbers in the third column of @tbl-pow-1 ($\{0, 1, 1, 1\}$). We line them up, multiplying them, and add them:

$$
(0 \times 1) + (1 \times 1) + (0 \times 1) + (1 \times 1) = 0 + 1 + 0 + 1 = 2
$$
Since we are working with a binary matrix, the product of each of the cell entries will be either a zero (when at least one of the entries is zero) or a one (when both entries are one). 

To get the cubed entries in @tbl-pow-3, we just take @tbl-pow-2 as the first matrix and @tbl-pow-1 as the second matrix, and do matrix multiplication magic. Thus, to get the number $4$ in the third row and fourth column of @tbl-pow-3, we take the numbers in the third row of @tbl-pow-2 $\{2, 1, 2, 2\}$ and the numbers in the fourth column of @tbl-pow-1 $\{1, 0, 1, 0\}$, line them up, multiply them, and add them:

$$
(2 \times 1) + (1 \times 0) + (2 \times 1) + (1 \times 0) = 2 + 0 + 2 + 0 = 4
$$

Pretty easy!



